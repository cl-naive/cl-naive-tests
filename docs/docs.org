# -*- mode:org;coding:utf-8 -*-

#+AUTHOR: Phil Marneweck
#+EMAIL: phil@psychedelic.co.za
#+DATE: June 27th, 2021
#+TITLE: User Manual for the cl-naive-tests library

#+BEGIN_EXPORT latex
\clearpage
#+END_EXPORT

* Prologue                                                         :noexport:

#+LATEX_HEADER: \usepackage[english]{babel}
#+LATEX_HEADER: \usepackage[autolanguage]{numprint} % Must be loaded *after* babel.
#+LATEX_HEADER: \usepackage{rotating}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage[margin=0.75in]{geometry}

# LATEX_HEADER: \usepackage{indentfirst}
# LATEX_HEADER: \setlength{\parindent}{0pt}
#+LATEX_HEADER: \usepackage{parskip}

#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{positioning, fit, calc, shapes, arrows}
#+LATEX_HEADER: \usepackage[underline=false]{pgf-umlsd}
#+LATEX_HEADER: \usepackage{lastpage}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \pagenumbering{arabic}
#+LATEX_HEADER: \lhead{\small{cl-naive-tests}}
#+LATEX_HEADER: \chead{}
#+LATEX_HEADER: \rhead{\small{User Manual}}
#+LATEX_HEADER: \lfoot{}
#+LATEX_HEADER: \cfoot{\tiny{\copyright{2021 Phil Marneweck}}}
#+LATEX_HEADER: \rfoot{\small{Page \thepage \hspace{1pt} de \pageref{LastPage}}}

* cl-naive-tests

A test framework that is not explicitly based on any of the mainstream
popular testing frameworks for other languages. It has a very simple
api, so the learning curve should be considerably less than for most
other frameworks.

The reason for its simplicity is that it focuses on managing and
reporting on tests. It does not try to introduce a testing
syntax/language. Even in managing and reporting it tries to not be
prescriptive and only implements the bare functional minimum.

It is also designed to work well with gitlab CI out of the box and
still be simple! Have a look at .gitlab-ci.yml in the project root
folder and for more on gitlab CI for list go to [[https://gitlab.com/Harag/sbcl-docker-gitlab-ci][sbcl-docker-gitlab-ci]]
to see how its possible.

* API

** [parameter] =*test-suites*=

=TEST-SUITES= are stored in here when defined.

** [parameter] =*suite-results*=

Test results of the last testsuite ran are stored here.
This variable is reset for each =RUN=.

** [macro] testsuite (identifier &body body)

Defines a =TESTSUITE=.

The =IDENTIFIER= is a symbol identifying the testsuite. (It is used as
=BLOCK= name which can be used to cut short the testsuite by calling
(return-from =/identifier/=) from the =BODY=).

The =BODY= is a list of lisp forms or =TESTCASE= forms.

The results of the =TESTCASE= are collected as results of the =TESTSUITE=.

** [macro] testcase  (identifier &key test-func test-data (equal 'equal) expected actual info)

"The =TESTCASE= macro evaluates the =ACTUAL= expression and compare its result with the =EXPECTED= expression.

The comparison is done either with the =TEST-FUNC= if provided, with the
=EQUAL= function.  If the comparison returns true, the test is
successful, otherwise it's a failure.  Test runs the test func
returning a plist with information about the result and test.

A plist containing the test info and results is returned.  It should
be used in the lambda that is registered with register-test.

=IDENTIFIER= is must be a symbol or a list of symbols.  By making it a
list of symbols the user is telling the system that the test is part
of a hierarchy of tests.  Statistics are calculated for the hierachy.
A example of a hierarchy would be like *junit* wants: /suites/, /suite/ and
/testcase/.

=TEST-FUNC= is the function that is run to determine the result of the
test.  If none is supplied, then the =EQUAL= function is used to
compare the =EXPECTED= and the =ACTUAL= values.  The =TEST-FUNC=
returns a failure-type: =T= or =:SUCCESS= in case of success, =NIL= or
=:FAILURE= in case of failure, or some other keyword if the test
wasn't run successfully, but this shouldn't be counted as a failure.
The =TEST-FUNC= is given two arguments: a plist containing
=:TEST-DATA= =:EXPECTED= =:ACTUAL= =:EXPRESSION=, and the
=INFO=. (=:ACTUAL= is the value of the =:EXPRESSION= that is tested;
if an error is signaled, it's passed in =:ERROR=).

=TEST-DATA= is a convenient place to store data the test relies on, this
can be used during the test and later in reporting on test results.
You can put what ever you want to in it.

=INFO= is a string to be read by the human that is digging into the
tests results, describing the test.

*** Example

#+BEGIN_SRC lisp
  (test (division non-zero-dividend)
        :equal '=
        :expected 3/2
        :actual (/ 3 2)
        :info \"Integer division by non-zero, giving a ratio.\")

  (test (division by-zero)
        :test-func (lambda (result info)
                     (let ((actual (getf result :actual)))
                       (cond ((eql (getf result :expected)
                              :success)
                             ((typep actual 'error)
                              (setf (aref (getf result :test-data) 0)
                                    (list 'unexpected-error (type-of actual)))
                              :failure)
                             (t
                              (setf (aref (getf result :test-data) 0)
                                    (list 'unexpected-result actual))
                              :failure))))
        :test-data (vector nil)
        :expected 'division-by-zero
        :actual (handler-case (/ 3 0)
                  (:no-error (result) result)
                  (division-by-zero () 'division-by-zero)
                  (error (err) err))
        :info \"Integer division by zero, giving a DIVISION-BY-ZERO
        error.\")
#+END_SRC

** [function] run (&key (tests *tests*) keep-stats-p)

Runs all tests passed in or all tests registered.

Statistics can be calculated during a test run, but the default is to
use statistics after a test run to calculate stats.

** [function] report (results)

Reports on the pass or failure of the results set over all. This does
not do any pretty printing etc because it needs to be machine
readable. If you want pretty reporting look at format-results or do
your own.

** [function] find-result (test-identifier results &key test)

Finds a result in the results.

** [function] calc-stats (result &optional (stats (make-hash-table :test #'equalp)))

Calculates stats. Stats are simple counts of tests, passed and failed
per level.  Stats are stored in a hashtable per identifier level,
which makes it easy to get to in format-results if needed.

** [function] statistics (results)

Can be used to calculate statistics post tests if *keep-stats-p* was
nil.

** [generic fucntion] format-results (format results)

/format-results (format results)/

Formats the results according to format.
The default method just outputs the results using lisp format string.

/format-results ((format (eql :junit)) results)/

"Formats then results as Junit XML, junits only allows 3 levels nl. suites, suite and testcase.
If your identifiers are not 1 or 3 levels this wont work for you.

** [function] write-results (results &key (file "results.log") format)

Writes results to file. If format is supplied formats results first using format-results.
This is used to produce files that could be used by some thing like gitlab CI.

* Epilogue                                                         :noexport:

# Local Variables:
# eval: (auto-fill-mode 1)
# End:
